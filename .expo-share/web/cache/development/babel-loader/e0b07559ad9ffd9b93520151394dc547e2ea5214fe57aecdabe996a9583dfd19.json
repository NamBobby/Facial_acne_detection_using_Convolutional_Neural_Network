{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useWebCameraStream = useWebCameraStream;\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar Utils = _interopRequireWildcard(require(\"./WebCameraUtils\"));\nvar _WebConstants = require(\"./WebConstants\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar VALID_SETTINGS_KEYS = ['autoFocus', 'flashMode', 'exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'whiteBalance', 'zoom'];\nfunction useLoadedVideo(video, onLoaded) {\n  React.useEffect(function () {\n    if (video) {\n      video.addEventListener('loadedmetadata', function () {\n        requestAnimationFrame(function () {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\nfunction useWebCameraStream(video, preferredType, settings, _ref) {\n  var onCameraReady = _ref.onCameraReady,\n    onMountError = _ref.onMountError;\n  var isStartingCamera = React.useRef(false);\n  var activeStreams = React.useRef([]);\n  var capabilities = React.useRef({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1\n  });\n  var _React$useState = React.useState(null),\n    _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n    stream = _React$useState2[0],\n    setStream = _React$useState2[1];\n  var mediaTrackSettings = React.useMemo(function () {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n  var type = React.useMemo(function () {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n    var _mediaTrackSettings$f = mediaTrackSettings.facingMode,\n      facingMode = _mediaTrackSettings$f === void 0 ? 'user' : _mediaTrackSettings$f;\n    return _WebConstants.FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n  var getStreamDeviceAsync = React.useCallback((0, _asyncToGenerator2.default)(function* () {\n    try {\n      return yield Utils.getPreferredStreamDevice(preferredType);\n    } catch (nativeEvent) {\n      if (__DEV__) {\n        console.warn(`Error requesting UserMedia for type \"${preferredType}\":`, nativeEvent);\n      }\n      if (onMountError) {\n        onMountError({\n          nativeEvent: nativeEvent\n        });\n      }\n      return null;\n    }\n  }), [preferredType, onMountError]);\n  var resumeAsync = React.useCallback((0, _asyncToGenerator2.default)(function* () {\n    var nextStream = yield getStreamDeviceAsync();\n    if (Utils.compareStreams(nextStream, stream)) {\n      return false;\n    }\n    if (!activeStreams.current.some(function (value) {\n      return value.id === (nextStream == null ? void 0 : nextStream.id);\n    })) {\n      activeStreams.current.push(nextStream);\n    }\n    setStream(nextStream);\n    if (onCameraReady) {\n      onCameraReady();\n    }\n    return false;\n  }), [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n  React.useEffect(function () {\n    if (isStartingCamera.current) {\n      return;\n    }\n    isStartingCamera.current = true;\n    resumeAsync().then(function (isStarting) {\n      isStartingCamera.current = isStarting;\n    }).catch(function () {\n      isStartingCamera.current = false;\n    });\n  }, [preferredType]);\n  React.useEffect(function () {\n    var changes = {};\n    for (var key of Object.keys(settings)) {\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\n        continue;\n      }\n      var nextValue = settings[key];\n      if (nextValue !== capabilities.current[key]) {\n        changes[key] = nextValue;\n      }\n    }\n    var hasChanges = !!Object.keys(changes).length;\n    var nextWebCameraSettings = Object.assign({}, capabilities.current, changes);\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n    capabilities.current = nextWebCameraSettings;\n  }, [settings.autoFocus, settings.flashMode, settings.exposureCompensation, settings.colorTemperature, settings.iso, settings.brightness, settings.contrast, settings.saturation, settings.sharpness, settings.focusDistance, settings.whiteBalance, settings.zoom]);\n  React.useEffect(function () {\n    if (!video.current) {\n      return;\n    }\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n  React.useEffect(function () {\n    return function () {\n      for (var _stream of activeStreams.current) {\n        Utils.stopMediaStream(_stream);\n      }\n      if (video.current) {\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n  useLoadedVideo(video.current, function () {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n  return {\n    type: type,\n    mediaTrackSettings: mediaTrackSettings\n  };\n}","map":{"version":3,"names":["React","_interopRequireWildcard","require","Utils","_WebConstants","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","VALID_SETTINGS_KEYS","useLoadedVideo","video","onLoaded","useEffect","addEventListener","requestAnimationFrame","useWebCameraStream","preferredType","settings","_ref","onCameraReady","onMountError","isStartingCamera","useRef","activeStreams","capabilities","autoFocus","flashMode","whiteBalance","zoom","_React$useState","useState","_React$useState2","_slicedToArray2","stream","setStream","mediaTrackSettings","useMemo","getTracks","getSettings","type","_mediaTrackSettings$f","facingMode","FacingModeToCameraType","getStreamDeviceAsync","useCallback","_asyncToGenerator2","getPreferredStreamDevice","nativeEvent","__DEV__","console","warn","resumeAsync","nextStream","compareStreams","current","some","value","id","push","then","isStarting","catch","changes","keys","includes","nextValue","hasChanges","length","nextWebCameraSettings","assign","syncTrackCapabilities","exposureCompensation","colorTemperature","iso","brightness","contrast","saturation","sharpness","focusDistance","setVideoSource","stopMediaStream"],"sources":["C:\\Users\\namha\\Documents\\Panda\\app\\ThesisMB\\node_modules\\expo-camera\\src\\useWebCameraStream.ts"],"sourcesContent":["/* eslint-env browser */\nimport * as React from 'react';\n\nimport {\n  CameraReadyListener,\n  CameraType,\n  MountErrorListener,\n  WebCameraSettings,\n} from './Camera.types';\nimport * as Utils from './WebCameraUtils';\nimport { FacingModeToCameraType } from './WebConstants';\n\nconst VALID_SETTINGS_KEYS = [\n  'autoFocus',\n  'flashMode',\n  'exposureCompensation',\n  'colorTemperature',\n  'iso',\n  'brightness',\n  'contrast',\n  'saturation',\n  'sharpness',\n  'focusDistance',\n  'whiteBalance',\n  'zoom',\n];\n\nfunction useLoadedVideo(video: HTMLVideoElement | null, onLoaded: () => void) {\n  React.useEffect(() => {\n    if (video) {\n      video.addEventListener('loadedmetadata', () => {\n        // without this async block the constraints aren't properly applied to the camera,\n        // this means that if you were to turn on the torch and swap to the front camera,\n        // then swap back to the rear camera the torch setting wouldn't be applied.\n        requestAnimationFrame(() => {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\n\nexport function useWebCameraStream(\n  video: React.MutableRefObject<HTMLVideoElement | null>,\n  preferredType: CameraType,\n  settings: Record<string, any>,\n  {\n    onCameraReady,\n    onMountError,\n  }: { onCameraReady?: CameraReadyListener; onMountError?: MountErrorListener }\n): {\n  type: CameraType | null;\n  mediaTrackSettings: MediaTrackSettings | null;\n} {\n  const isStartingCamera = React.useRef<boolean | null>(false);\n  const activeStreams = React.useRef<MediaStream[]>([]);\n  const capabilities = React.useRef<WebCameraSettings>({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1,\n  });\n  const [stream, setStream] = React.useState<MediaStream | null>(null);\n\n  const mediaTrackSettings = React.useMemo(() => {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n\n  // The actual camera type - this can be different from the incoming camera type.\n  const type = React.useMemo(() => {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n    // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\n    const { facingMode = 'user' } = mediaTrackSettings;\n    return FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n\n  const getStreamDeviceAsync = React.useCallback(async (): Promise<MediaStream | null> => {\n    try {\n      return await Utils.getPreferredStreamDevice(preferredType);\n    } catch (nativeEvent) {\n      if (__DEV__) {\n        console.warn(`Error requesting UserMedia for type \"${preferredType}\":`, nativeEvent);\n      }\n      if (onMountError) {\n        onMountError({ nativeEvent });\n      }\n      return null;\n    }\n  }, [preferredType, onMountError]);\n\n  const resumeAsync = React.useCallback(async (): Promise<boolean> => {\n    const nextStream = await getStreamDeviceAsync();\n    if (Utils.compareStreams(nextStream, stream)) {\n      // Do nothing if the streams are the same.\n      // This happens when the device only supports one camera (i.e. desktop) and the mode was toggled between front/back while already active.\n      // Without this check there is a screen flash while the video switches.\n      return false;\n    }\n\n    // Save a history of all active streams (usually 2+) so we can close them later.\n    // Keeping them open makes swapping camera types much faster.\n    if (!activeStreams.current.some((value) => value.id === nextStream?.id)) {\n      activeStreams.current.push(nextStream!);\n    }\n\n    // Set the new stream -> update the video, settings, and actual camera type.\n    setStream(nextStream);\n    if (onCameraReady) {\n      onCameraReady();\n    }\n    return false;\n  }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n\n  React.useEffect(() => {\n    // Restart the camera and guard concurrent actions.\n    if (isStartingCamera.current) {\n      return;\n    }\n    isStartingCamera.current = true;\n\n    resumeAsync()\n      .then((isStarting) => {\n        isStartingCamera.current = isStarting;\n      })\n      .catch(() => {\n        // ensure the camera can be started again.\n        isStartingCamera.current = false;\n      });\n  }, [preferredType]);\n\n  // Update the native camera with any custom capabilities.\n  React.useEffect(() => {\n    const changes: WebCameraSettings = {};\n\n    for (const key of Object.keys(settings)) {\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\n        continue;\n      }\n      const nextValue = settings[key];\n      if (nextValue !== capabilities.current[key]) {\n        changes[key] = nextValue;\n      }\n    }\n\n    // Only update the native camera if changes were found\n    const hasChanges = !!Object.keys(changes).length;\n\n    const nextWebCameraSettings = { ...capabilities.current, ...changes };\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n\n    capabilities.current = nextWebCameraSettings;\n  }, [\n    settings.autoFocus,\n    settings.flashMode,\n    settings.exposureCompensation,\n    settings.colorTemperature,\n    settings.iso,\n    settings.brightness,\n    settings.contrast,\n    settings.saturation,\n    settings.sharpness,\n    settings.focusDistance,\n    settings.whiteBalance,\n    settings.zoom,\n  ]);\n\n  React.useEffect(() => {\n    // set or unset the video source.\n    if (!video.current) {\n      return;\n    }\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n\n  React.useEffect(() => {\n    return () => {\n      // Clean up on dismount, this is important for making sure the camera light goes off when the component is removed.\n      for (const stream of activeStreams.current) {\n        // Close all open streams.\n        Utils.stopMediaStream(stream);\n      }\n      if (video.current) {\n        // Invalidate the video source.\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n\n  // Update props when the video loads.\n  useLoadedVideo(video.current, () => {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n\n  return {\n    type,\n    mediaTrackSettings,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}